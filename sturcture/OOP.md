## OOP

### 객체지향 프로그래밍
> 객체(Object)들이 모여서 상호 협력하면서 데이터를 처리하는 방식
#### 키워드 : `객체` `협력과 책임, 역할` `메시지` `자율성(의인화)` `다형성`
#### 객체란 무엇인가?
> 현실의 무언가에 대응(추상화)하는 개념 (클래스는 객체를 잘 표현하기 위한 수단)

- 다른 객체와 **협력(Collaboration)** 하는 **역할(role)** 을 맡고 있는 대상
- **역할(role)** 을 맡으면 임무를 수행할 **책임(responsibility)** 이 생긴다.
- 책임을 다하기 위한 데이터와 프로세스를 가지고 있다.
    - `협력` : 시스템 목표를 달성하기 위해 여러 객체가 참여하여 행동하는 것
    - `책임` : 협력 속에서 본인이 수행해야 할 임무의 내용을 알고, 수행하는 것
    - `역할` : 동일한 목적을 가진 책임의 묶음
    - `메시지` : 객체는 메시지를 통해 다른 객체에게 책임을 다하라고 요구한다.
        - 메시지를 보내는 객체는 **무엇을** 할지만 요구하고, **어떻게** 하는지는 신경 쓰지X
        - 객체는 **책임**을 수행하라고 요구받지만, 어떻게 처리할 지는 **자율**에 맡긴다.
    - `자율성` :
        - 객체지향과 현실세계의 차이점
            - 현실 세계의 치킨 가게는 건물에 불과하다.
            - 객체지향 세계의 치킨 가게는 스스로 치킨을 튀기고, 치킨을 건네어 준다.
        - 즉, 객체지향에선 객체가 자율적으로, 능동적으로 행동할 수 있다고 **의인화** 하여야 한다.
        - 자율적으로 메시지를 처리하기 위해서 자신의 책임을 수행하는 데 필요한 데이터와 프로세스를 가지고 있다.
    - `다형성` :
        - 다형성을 활용하는 목적은 서로 다른 유형의 객체가 동일한 메시지에 대해 다르게 반응하게 하기 위해서이다.
        - 동일한 메시지를 처리한다 == 같은 역할을 수행한다
        - 다르게 반응한다 == 메시지 처리 방법은 자율적이다
```java 
// 자바에서는 메서드를 호출함으로써 메시지를 보낸다.
class ChickenShop {
    public void cookChicken() { // 메서드 이름과 리턴 타입은 메시지를 포함한다
        // 치킨을 요리하라는 메시지를 받아 요리를 시작한다
        // 자신만의 방법으로 요리를 한다
    }
    public void deliverChicken() {
        // 치킨을 다른 객체에게 전달한다
    }
}
```
#### 정리
> 1. 객체는 현실의 개념을 추상화한 것이다.
> 2. 객체들은 서로 협력하고, 역할을 맡아 책임을 수행하여 문제상황을 해결한다.
> 3. 하지만 현실의 사물과 달리 객체는 능동적이고 자율적인 존재이다.

### 객체지향적으로 설계하기
#### 데이터 중심의 설계
> 현실 세계를 반영하기 위한 설계를 시작하면 자칫 데이터 중심의 설계를 하기 쉽다.

- 데이터 중심 설계의 문제점
    - getter, setter가 과도하게 추가되어 **결합도가 높아진다.** (서로 알고 있는 객체가 많아진다.)
        - 결합도가 높아지면 하나의 변경이 일어났을 때 다수의 수정이 일어나므로 유지보수성이 떨어진다.
    - 데이터를 처리하는 작업과 데이터가 분리되어 **응집도가 낮아진다.**

#### 책임 주도 개발
- 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임(협력)을 파악한다.
    - 치킨 주문을 받아 손님에게 배달해야한다.
- 시스템 책임을 더 작은 책임으로 분할한다.
    - 메시지를 생성한다.
        - 치킨 주문을 받는다.
        - 치킨을 요리한다.
        - 치킨을 손님에게 배달한다.
- 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다.
    - 사용자 -> (치킨을 주문하라) -> 치킨 가게
    - 치킨 가게 -> (치킨을 요리하라) -> 요리사 -> (치킨을 배달하라) -> 배달원
- 객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다.
- 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 한다.
```java
class ChickenShop {
    private Chef chef = new Chef();
    
    public void takeOrder() {
        chef.cook();
    }
}

class Chef {
    private Driver driver = new Driver();
    private Chicken chicken;
    
    public void cook() {
        chicken = new FriedChicken();
        driver.deliver(chicken);
    }
}

class Driver {
    public void deliver(Chicken chicken) {
        
    }
}

```
### 추상화 (Abstraction)
> 구체화와 반대되는 개념으로, 객체의 공통된 특성을 뽑아서 일반화하는 것을 의미한다.

#### 추상화의 종류
- 제어 추상화 : 사용자에게 해당 메서드의 작동방식과 같은 내부 로직을 숨기는 것을 의미한다.
    - 효과
        - 생산성 증가, 가독성 증가, 에러 감소, 유지 보수 시 시간 단축
    - 예시
        - 자동차의 기능만 알면 되지 내부적인 작동 원리를 알 필요가 없다.
- 데이터 추상화 : 대상을 간단한 개념으로 일반화하는 과정을 의미한다.
    - 예시
        - 아이폰(애플 앱 연동 기능) -> 휴대폰(카메라, 게임 기능) -> 통신기기(통화 기능) -> 전자제품(전원 기능)
    - 효과
        - 공통 기능을 상위 요소에서 미리 구현하기 때문에 아이폰만의 고유한 기능을 위주로 개발할 수 있다.
        - 공통 기능을 미리 구현해두면 제품의 종류가 늘어날 수록 상속을 통해 빠르게 구조를 확장할 수 있다.

#### 추상화 수준
> 객체가 가지는 추상화 정도, 통일된 추상화 수준을 가지는 객체는 읽기 쉽다.

- private 메서드가 하는 역할을 다른 객체로 위임한다.
- 추상화 수준이 높은 곳에서 낮은 방향으로 메시지를 보낸다.
- 여러 추상화 수준이 하나의 객체에 존재한다면, 다른 객체를 활용한다.

### 상속 (Inheritance)
> 상위 클래스의 변수와 메서드를 재사용하여 하위 클래스가 **전부** 물려받는 것을 의미한다.

효과 : 상속을 통해 코드의 중복을 제거하고, 코드 재사용성 증대할 수 있다.
예시 :

```java
class Animal {
    int legCount;
    int tailCount;
}

class Dog extends Animal {
    void bark();
}

class Cat extends Animal {
    void meow();
}
```

#### 참고 자료
- [링크1 | OOP 테코톡](https://www.youtube.com/watch?v=3etKkkna-f0)
- [링크2 | OOP, 추상화, 상속 정리 블로그](https://inpa.tistory.com/entry/OOP-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EA%B0%9C%EB%85%90%EA%B3%BC-%EC%B6%94%EC%83%81%ED%99%94-%EC%84%A4%EA%B3%84%EC%9D%98-%EC%9D%B4%ED%95%B4)